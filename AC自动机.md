# AC自动机

**By JerryDream&jpy_cpp,Nanjing Foreign Language School**

**3rd August,2021**

**内容摘要**：AC自动机的基本算法结构以及实现

**关键字**：C++ 算法 字符串 AC自动机

## 引言

本文为介绍类论文，具体介绍AC自动机的基本算法结构以及实现。

文中有多处存在图片以及gif，帮助读者更好理解。

## 概述

AC自动机是**以Trie的结构为基础**，结合**KMP的思想**建立的。

简而言之，建立一个AC自动机有2个步骤：

1. 基础的Trie结构：将所有的模式串构成一棵Trie。
2. KMP的思想：对Trie树上所有结点构成失配指正。

然后就可以利用它进行多模式匹配了。

## 字典树构建

AC自动机在初始时会将若干个模式串丢到一个Trie里，然后再Trie上建立AC自动机。这个Trie就是普通的Trie，该怎么建怎么建。

这里需要解释一下Trie结点的含义，Trie中的结点表示某个模式串的前缀。我们在后文也将其称作状态。一个结点表示一个状态，Trie的边就是状态的转移。

形式化地说，对于若干个模式串$s_1,s_2\cdots s_n$，将它们构建一棵字典树的所有状态集合记为$Q$。

## 失配指针

AC自动机用一个fail指针来辅助多模式串的匹配。

状态$u$的fail指针指向另一个状态$v$，其中$v\in Q$，且$v$是$u$的最长后缀（即在若干个后缀状态中取最长的一个座位fail指针）。fail指针和KMP中的next指针的比较;

1. 共同点：两者同样是在失配的时候用于跳转的指针。
2. 不通电：next指针求的是最长的border（即最长的相同前后缀），而fail指针指向所有模式串的前缀中匹配当前状态的最长后缀。

因为KMP只对一个模式串做匹配，而AC自动机要对多个模式串做匹配。有可能fail指针指向的结点对应这另一个模式串，两者前缀不同。

AC自动机在做匹配时，同一位上可以匹配多个模式串。

## 构建指针

下面介绍构建fail指针的==基础思想==：

构建fail指针，可以参考KMP中构造next指针的思想。

考虑字典树中当前的结点$u$，$u$的父节点是$p$，$p$通过字符`c`，即$trie[p,c]=u$。假设深度小于$u$的所有结点的fail指针都已求得。

1. 如果$trie[fail[p],c]$存在：则让$u$的fail指针指向$trie[fail[p],c]$。相当于在$p$和$fail[p]$后面加上一个赐福`c`，分别对应$u$和$fail[u]$。
2. 如果$trie[fail[p],c]$不存在：那么我们继续找到$trie[fail[fail[p]],c]$。重复1的判断过程，一直跳fail指针指向根节点。
3. 如果真的没有，就让fail指针指向根节点。

如此完成了$fail[u]$的构建。

例子

下面是一张gif帮助理解。对于字符串`i he his she hers`组成的的字典树构建fail指针：

1. 黄色结点：当前的结点$u$。
2. 绿色结点：表示已经BFS遍历完毕的结点。
3. 橙色的边：fail指针。
4. 红色的边：当前求出的fail指针。

![](C:\Users\ibm\Desktop\MD PDF\别删\ac-automaton1.gif)

我们重点分析结点6的fail指针构建：

![](C:\Users\ibm\Desktop\MD PDF\别删\ac-automaton1.png)

找到6的父节点5，$fail[5]=10$。然而10结点没有字母`s`的出边；继续跳到10的fail指针，$fail[10]=0$。发现0结点有字母`s`的出边，指向7结点；所以$fail[6]=7$。最后是建出来的图：

![](C:\Users\ibm\Desktop\MD PDF\别删\ac-automaton4.png)

## 字典树与字典图

先来看构造函数`build()`，该函数目标有2个，一个是构建fail指针，一个是构建自动机。参数如下：

1. `tr[u,c]`：有两种理解方式。我们可以简单理解为字典树上的一条边，即$trie[u][c]$；也可以理解为从状态（结点）$u$后加一个字符`c`到达的状态（结点），即一个状态转移函数$trans(u,c)$。下文中我们将用第二种理解方式讲解。
2. 队列$q$：用于BFS遍历字典树。
3. `fail[u]`：结点$u$的$fail$指针。

```c++
void build() {
  for (int i = 0; i < 26; i++)
    if (tr[0][i]) q.push(tr[0][i]);
  while (q.size()) {
    int u = q.front();
    q.pop();
    for (int i = 0; i < 26; i++) {
      if (tr[u][i])
        fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);
      else
        tr[u][i] = tr[fail[u]][i];
    }
  }
}
```
